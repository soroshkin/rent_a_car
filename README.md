# Simple application for rent-a-car service
#JPA
1. В файле persistence.xml добавлено два persistence unit для подключений к базам PostgreSQL(rental-cars) и H2(test).
2. Сделал тесты для тестирования DAO, сущностей, отношений и ограничений для полей классов. 
3. Настройки выбора базы данных находятся в классе  AppSettings. По умолчанию используется persistence 
unit "test" с базой данных H2.
4. CRUD операции осуществляются через статические методы класса EntityManagerUtil, получение данных из базы вне транзакций, 
обновление добавление удаление внутри транзакций, EntityManager Каждый раз создается заново и закрывается.

#База данных
1. Приложение для сервиса прокатных автомобилей состоит из следующих сущностей: Пользователь, Счет, Автомобиль, Пасспорт, Чек.
 У пользователя может быть только один счет, к одному счету привязан только один пользователь (Один к одному), 
 счет без пользователя существовать не может. Во-первых, у Account нет публичного конструктора без аргумента User, но даже если бы он был,
 то Hibernate бы выдал ошибку IdentifierGenerationException, потому что не может получить id из null сущности.
 Для тестирования операций с аккаунтом используется класс JpaAccountDAOTest. В нем же есть метод testTwoAccountToOneUserShouldFail(),
 который тестирует попытку присвоения одному пользователю два разных аккаунта. При удалении пользователя автоматически удаляется связанный с ним акааунт.
 За это отвечает аннотация @OnDelete(action = OnDeleteAction.CASCADE), она добавляет к SQL запросу ON DELETE CASCADE, что приводит к 
 каскадному удалению сущностей. Проверить можно в методе deleteIfHasNoBillsPassports класса JpaUserDAOTest. Удаление аккаунта не приводит к 
 удалению пользователя (метод delete класса JpaAccountDAOTest). В классе RelationshipsTest есть метод для проверки каскадного создания аккаунта tryAutoCreationOfAccounts.
 2. У каждого пользователя может быть несколько паспортов (например, приложение работает в разных странах, соответственно у пользователя появляется загран.паспорт).
 Связь один-ко-многим. Паспорт добавляется методом addPassport в сущности User. При добавлении паспорта и сохранении через JpaUserDAO автоматически создается новая запись в таблице Паспорт, это происходит благодаря элементу cascade = CascadeType.ALL.
 Это можно проверить в методе deleteIfHasPassports класса JpaUserDAOTest. В методе removeOrphanPassports происходит проверка правильности работы элемента orphanRemoval, 
 то же самое только с помощью CriteriaAPI в методе oToMRelationshipUserPassportOrphanRemove() класса RelationshipsTest. 
 При удалении паспорта из коллекции в сущности пользователь, удаляется запись паспорта из таблицы. При удалении записи паспорта из таблицы удаления пользователя не происходит (deletePassport, JpaPassportDAOTest).
 При удалении пользователя, у которого есть паспорта выбрасывается исключение (сначала нужно удалить паспорта, методы deleteIfHasPassports, deleteIfHasNoBillsPassports).
 3. Аналогично построены отношения User-Bill и Bill-Car.
 4. Также имеется связь многие-ко-многим User-Car. Один пользователь ездит на разных машинах, одна машина сдается в аренду многим пользователям.
 Для отображения отношения создается промежуточная таблица trips, которая содержит составной первичный ключ, состоящий из двух внешних user_if, car_id.
 Проверка осуществляется в методе mToMRelationshipUserCars класса RelationshipsTest.
 5. Есть возможность подключения к базам: H2, PostgreSQL. По умолчанию используется H2.
 
 #Spring MVC
 1. Настройка осуществлена с помощью аннотаций. В классе PersistenceJpaConfig при каждом создании контекста база данных заполняется тестовыми данными из SQL скрипта.
 Репозиторий  имеет интерфейс и несколько реализаций, в частности, с помощью Spring Data и на JPA. 
 Чтобы приложение могло создать контекст (исключить конфликт между бинами репозитория) используются профили, в методе onStartup указывается профиль, с которым оно должно быть запущено,
 тесты запускаются с аннотацией @ActiveProfiles.
 
 #Frontend
 1. Создана страница для выполнения crud операций с сущностями user, account.
 
 #Markup Languages
 1. Создан класс JPAJacksonObjectMapper для сериализации/десериализации объектов в/из файла - эта реализация работает без Spring.
 Для сериализации/десериализации Spring в классе WebConfig определен бин класса MappingJackson2HttpMessageConverter, из которого можно получить объект класса ObjectMapper.
 В классе JsonController сериализуется/десериализуется список сущностей Паспорт и результат отправляется на view. Эти функции можно протестировать, запустив приложение и на главной странице нажав ссылку JsonTest page, либо через тесты класса JsonTestController.
 Класс JPAJacksonObjectMapper тестируется в классе JPAJacksonObjectMapperTest.
